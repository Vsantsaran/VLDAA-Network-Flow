<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ford-Fulkerson Visualizer (Final Grid Fix)</title>
<style>
/* Light Theme CSS */
:root {
  --bg-primary: #f8fafc;
  --bg-secondary: #ffffff;
  --bg-tertiary: #f1f5f9;
  --bg-card: #ffffff;
  --accent-primary: #3b82f6;
  --accent-secondary: #6366f1;
  --accent-success: #10b981;
  --accent-warning: #f59e0b;
  --accent-error: #ef4444;
  --accent-info: #06b6d4;
  --text-primary: #1e293b;
  --text-secondary: #475569;
  --text-muted: #64748b;
  --border-subtle: #e2e8f0;
  --border-medium: #cbd5e1;
  --border-strong: #94a3b8;
  --glow-primary: rgba(59, 130, 246, 0.1);
  --glow-success: rgba(16, 185, 129, 0.1);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #f0f9ff 0%, #f8fafc 100%);
  color: var(--text-primary);
  min-height: 100vh;
  line-height: 1.5;
}

.container {
  display: grid;
  grid-template-columns: minmax(280px, 320px) 1fr minmax(280px, 320px);
  grid-template-rows: auto 1fr;
  height: 100vh;
  gap: 0;
  background: var(--bg-primary);
}

/* Header Styles */
.header {
  grid-column: 1 / -1;
  background: linear-gradient(90deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
  padding: 1rem 1.5rem;
  border-bottom: 1px solid var(--border-subtle);
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: var(--shadow-sm);
  position: sticky;
  top: 0;
  z-index: 100;
}

.logo-section {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.logo-title {
  font-size: 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  letter-spacing: -0.5px;
}

.logo-subtitle {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-weight: 500;
}

.header-stats {
  display: flex;
  gap: 1.5rem;
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem 0.75rem;
  background: var(--bg-tertiary);
  border-radius: 0.5rem;
  border: 1px solid var(--border-subtle);
  min-width: 100px;
}

.stat-label {
  font-size: 0.7rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-weight: 600;
}

.stat-value {
  font-size: 1.25rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: var(--accent-primary);
}

/* Panel Styles */
.panel {
  background: var(--bg-secondary);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-subtle);
}

.panel-right {
  border-right: none;
  border-left: 1px solid var(--border-subtle);
}

.panel-header {
  padding: 1.25rem;
  border-bottom: 1px solid var(--border-subtle);
  position: sticky;
  top: 0;
  background: var(--bg-secondary);
  z-index: 10;
}

.panel-title {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.panel-title::before {
  content: '';
  width: 3px;
  height: 16px;
  background: var(--accent-primary);
  border-radius: 2px;
  display: block;
}

.panel-content {
  padding: 1.25rem;
  flex: 1;
}

/* Input Section */
.input-section {
  margin-bottom: 1.5rem;
}

.section-title {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 0.75rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.preset-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.preset-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-medium);
  color: var(--text-secondary);
  padding: 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.preset-btn:hover {
  border-color: var(--accent-primary);
  color: var(--accent-primary);
  background: var(--glow-primary);
}

.preset-btn.active {
  background: var(--glow-primary);
  border-color: var(--accent-primary);
  color: var(--accent-primary);
}

.input-group {
  margin-bottom: 1rem;
}

.input-label {
  display: block;
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-bottom: 0.5rem;
  font-weight: 500;
}

.input-field {
  width: 100%;
  background: var(--bg-secondary);
  border: 1px solid var(--border-medium);
  color: var(--text-primary);
  padding: 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  transition: all 0.2s ease;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  resize: vertical;
}

.input-field:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 3px var(--glow-primary);
}

.input-field::placeholder {
  color: var(--text-muted);
}

.control-btn {
  width: 100%;
  padding: 0.875rem;
  border: none;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.control-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
  color: white;
  box-shadow: var(--shadow-md);
}

.btn-primary:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: var(--shadow-lg);
}

.btn-secondary {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--border-medium);
}

.btn-secondary:hover:not(:disabled) {
  border-color: var(--accent-primary);
  background: var(--glow-primary);
}

.btn-group {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.5rem;
  margin-top: 0.5rem;
}

/* Center Panel - Graph Visualization */
.center-panel {
  background: var(--bg-primary);
  display: flex;
  flex-direction: column;
  padding: 1rem;
  overflow: hidden;
}

.graph-container {
  flex: 1;
  background: var(--bg-secondary);
  border-radius: 0.75rem;
  border: 1px solid var(--border-subtle);
  overflow: auto;
  padding: 2rem;
  box-shadow: var(--shadow-sm);
  position: relative;
}

.graph-visualization {
  min-width: 800px;
  min-height: 500px;
  position: relative;
  transform-origin: center;
  transition: transform 0.3s ease;
}

/* Graph Elements */
.node {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 1.25rem;
  color: white;
  box-shadow: var(--shadow-md);
  z-index: 2;
  transition: all 0.3s ease;
  border-radius: 50%;
  cursor: pointer;
}

.node.source {
  background: linear-gradient(135deg, var(--accent-success), #059669);
}

.node.sink {
  background: linear-gradient(135deg, var(--accent-error), #dc2626);
}

.node.regular {
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
}

.node.active {
  animation: pulse 1.5s infinite;
  box-shadow: 0 0 0 10px rgba(59, 130, 246, 0.1);
}

.node.cut-side {
  border: 3px solid var(--accent-success);
}

.node.non-cut-side {
  border: 3px solid var(--accent-error);
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.node-label {
  position: absolute;
  top: -30px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.75rem;
  color: var(--text-secondary);
  font-weight: 600;
  white-space: nowrap;
  background: var(--bg-secondary);
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  border: 1px solid var(--border-subtle);
}

.edge {
  position: absolute;
  pointer-events: none;
  z-index: 1;
}

.edge-line {
  stroke-width: 3;
  fill: none;
  transition: all 0.3s ease;
}

.edge-line.active {
  stroke-width: 4;
  animation: flow 2s linear infinite;
}

.edge-line.cut-edge {
  stroke-width: 4;
  stroke-dasharray: 5,5;
  stroke: var(--accent-error);
}

@keyframes flow {
  to {
    stroke-dashoffset: 20;
  }
}

.edge-label {
  position: absolute;
  background: var(--bg-secondary);
  border: 1px solid var(--border-medium);
  border-radius: 0.5rem;
  padding: 0.375rem 0.75rem;
  font-size: 0.75rem;
  font-family: 'JetBrains Mono', monospace;
  font-weight: 600;
  color: var(--text-primary);
  box-shadow: var(--shadow-sm);
  z-index: 3;
  text-align: center;
  min-width: 70px;
}

.edge-flow {
  color: var(--accent-success);
  font-weight: 700;
}

.edge-capacity {
  color: var(--text-muted);
  font-size: 0.7rem;
}

.edge-arrow {
  position: absolute;
  width: 0;
  height: 0;
  border-style: solid;
}

/* Graph Controls */
.graph-controls {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-top: 1rem;
  padding: 1rem;
  background: var(--bg-secondary);
  border-radius: 0.75rem;
  border: 1px solid var(--border-subtle);
  box-shadow: var(--shadow-sm);
}

.graph-control-btn {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-medium);
  color: var(--text-secondary);
  padding: 0.625rem 1rem;
  border-radius: 0.5rem;
  font-size: 0.75rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  min-width: 120px;
}

.graph-control-btn:hover {
  border-color: var(--accent-primary);
  color: var(--accent-primary);
  background: var(--glow-primary);
}

.graph-control-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.key-hint {
  font-size: 0.7rem;
  color: var(--text-muted);
  margin-left: auto;
}

/* Metrics Cards */
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
  margin-bottom: 1.5rem;
}

.metric-card {
  background: var(--bg-card);
  border: 1px solid var(--border-subtle);
  border-radius: 0.75rem;
  padding: 1rem;
  transition: all 0.2s ease;
}

.metric-card:hover {
  border-color: var(--accent-primary);
  box-shadow: var(--shadow-md);
}

.metric-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.metric-name {
  font-size: 0.75rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-weight: 600;
}

.metric-value {
  font-size: 1.5rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: var(--accent-primary);
}

.metric-description {
  font-size: 0.75rem;
  color: var(--text-muted);
  line-height: 1.4;
}

/* Path History */
.path-history {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-subtle);
  border-radius: 0.75rem;
  padding: 1rem;
  max-height: 200px;
  overflow-y: auto;
  margin-bottom: 1.5rem;
}

.path-history-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.path-item {
  background: var(--bg-secondary);
  border-radius: 0.5rem;
  padding: 0.75rem;
  margin-bottom: 0.5rem;
  border-left: 3px solid var(--accent-primary);
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.path-nodes {
  color: var(--text-primary);
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.path-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.7rem;
}

.path-flow {
  color: var(--accent-success);
  font-weight: 700;
  background: rgba(16, 185, 129, 0.1);
  padding: 0.125rem 0.375rem;
  border-radius: 0.25rem;
}

/* Explanation Panel */
.explanation-panel {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-subtle);
  border-radius: 0.75rem;
  padding: 1rem;
  margin-bottom: 1rem;
  max-height: 300px;
  overflow-y: auto;
}

.explanation-step {
  display: none;
  padding: 0.75rem;
  background: var(--bg-secondary);
  border-radius: 0.5rem;
  margin-bottom: 0.5rem;
  border-left: 3px solid var(--accent-info);
}

.explanation-step.active {
  display: block;
  animation: slideIn 0.3s ease;
}

.explanation-step h4 {
  font-size: 0.875rem;
  margin-bottom: 0.5rem;
  color: var(--text-primary);
}

.explanation-step p {
  font-size: 0.8rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

/* Execution Log */
.log-panel {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-subtle);
  border-radius: 0.75rem;
  padding: 1rem;
  max-height: 200px;
  overflow-y: auto;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 0.75rem;
}

.log-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.log-entry {
  padding: 0.375rem 0;
  border-bottom: 1px solid var(--border-subtle);
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
}

.log-entry:last-child {
  border-bottom: none;
}

.log-time {
  color: var(--text-muted);
  font-size: 0.7rem;
  min-width: 45px;
}

.log-message {
  flex: 1;
  word-break: break-word;
}

.log-entry.success .log-message { color: var(--accent-success); }
.log-entry.warning .log-message { color: var(--accent-warning); }
.log-entry.error .log-message { color: var(--accent-error); }
.log-entry.info .log-message { color: var(--accent-info); }

/* Status Bar */
.status-bar {
  grid-column: 1 / -1;
  background: var(--bg-secondary);
  border-top: 1px solid var(--border-subtle);
  padding: 0.75rem 1.5rem;
  font-size: 0.875rem;
  color: var(--text-secondary);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.keyboard-shortcuts {
  display: flex;
  gap: 1rem;
  font-size: 0.75rem;
}

.shortcut {
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.shortcut kbd {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-medium);
  border-radius: 0.25rem;
  padding: 0.125rem 0.375rem;
  font-size: 0.7rem;
  font-family: 'JetBrains Mono', monospace;
}

/* Min-Cut Visualization */
.min-cut-info {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-subtle);
  border-radius: 0.75rem;
  padding: 1rem;
  margin-bottom: 1rem;
  display: none;
}

.min-cut-info.show {
  display: block;
  animation: slideIn 0.3s ease;
}

.min-cut-title {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.min-cut-content {
  font-size: 0.8rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.min-cut-sets {
  display: flex;
  gap: 1rem;
  margin: 0.5rem 0;
}

.min-cut-set {
  flex: 1;
  padding: 0.5rem;
  background: var(--bg-secondary);
  border-radius: 0.5rem;
  border: 1px solid var(--border-medium);
}

.min-cut-set-label {
  font-size: 0.7rem;
  color: var(--text-muted);
  margin-bottom: 0.25rem;
}

.min-cut-set-nodes {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.75rem;
  color: var(--text-primary);
}

.cut-edge-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.25rem 0;
  border-bottom: 1px solid var(--border-subtle);
}

.cut-edge-item:last-child {
  border-bottom: none;
}

/* Responsive Design */
@media (max-width: 1200px) {
  .container {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr auto;
  }
  
  .panel {
    max-height: 400px;
  }
  
  .center-panel {
    order: 1;
  }
  
  .panel-left {
    order: 2;
  }
  
  .panel-right {
    order: 3;
  }
}

@media (max-width: 768px) {
  .header {
    flex-direction: column;
    gap: 1rem;
    text-align: center;
  }
  
  .header-stats {
    width: 100%;
    justify-content: center;
  }
  
  .stat-item {
    min-width: 80px;
  }
  
  .preset-grid {
    grid-template-columns: 1fr;
  }
  
  .metrics-grid {
    grid-template-columns: 1fr;
  }
  
  .graph-controls {
    flex-wrap: wrap;
  }
  
  .graph-control-btn {
    min-width: auto;
    flex: 1;
  }
  
  .keyboard-shortcuts {
    display: none;
  }
}

/* Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-tertiary);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--border-medium);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-strong);
}

/* Loading Animation */
.loading {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid rgba(59, 130, 246, 0.3);
  border-radius: 50%;
  border-top-color: var(--accent-primary);
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Toast Notifications */
.toast {
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 1rem;
  background: var(--bg-secondary);
  border: 1px solid var(--border-medium);
  border-radius: 0.75rem;
  box-shadow: var(--shadow-lg);
  z-index: 1000;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  animation: slideInRight 0.3s ease;
  max-width: 350px;
}

.toast.success {
  border-left: 4px solid var(--accent-success);
}

.toast.warning {
  border-left: 4px solid var(--accent-warning);
}

.toast.error {
  border-left: 4px solid var(--accent-error);
}

.toast.info {
  border-left: 4px solid var(--accent-info);
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
</head>
<body>

<div class="container">
  <header class="header">
    <div class="logo-section">
      <div class="logo-title">Ford–Fulkerson Visualizer</div>
      <div class="logo-subtitle">Maximum Flow Algorithm Visualization</div>
    </div>
    <div class="header-stats">
      <div class="stat-item">
        <div class="stat-label">Max Flow</div>
        <div class="stat-value" id="headerFlow">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Paths</div>
        <div class="stat-value" id="headerPaths">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Time</div>
        <div class="stat-value" id="headerTime">0ms</div>
      </div>
    </div>
  </header>

  <div class="panel panel-left">
    <div class="panel-header">
      <div class="panel-title">Configuration</div>
    </div>
    <div class="panel-content">
      <div class="input-section">
        <div class="section-title">
          <i class="fas fa-project-diagram"></i> Network Presets
        </div>
        <div class="preset-grid">
          <button class="preset-btn active" data-preset="simple">
            <i class="fas fa-code-branch"></i> Simple
          </button>
          <button class="preset-btn" data-preset="medium">
            <i class="fas fa-sitemap"></i> Medium
          </button>
          <button class="preset-btn" data-preset="complex">
            <i class="fas fa-network-wired"></i> Complex
          </button>
          <button class="preset-btn" data-preset="large">
            <i class="fas fa-layer-group"></i> Large
          </button>
        </div>
      </div>

      <div class="input-section">
        <div class="section-title">
          <i class="fas fa-edit"></i> Graph Definition
        </div>
        <div class="input-group">
          <label class="input-label">Edges (format: u v capacity)</label>
          <textarea class="input-field" id="graphInput" rows="6">0 1 10
0 2 5
1 3 10
2 3 10</textarea>
        </div>
        <div class="input-group">
          <label class="input-label">Source Node</label>
          <input type="number" class="input-field" id="sourceInput" value="0" min="0">
        </div>
        <div class="input-group">
          <label class="input-label">Sink Node</label>
          <input type="number" class="input-field" id="sinkInput" value="3" min="0">
        </div>
      </div>

      <div class="input-section">
        <div class="section-title">
          <i class="fas fa-play-circle"></i> Algorithm Controls
        </div>
        <button class="control-btn btn-primary" id="initBtn">
          <i class="fas fa-play"></i> Initialize Graph
        </button>
        <div class="btn-group">
          <button class="control-btn btn-secondary" id="stepBtn" disabled>
            <i class="fas fa-step-forward"></i> Step
          </button>
          <button class="control-btn btn-secondary" id="autoBtn" disabled>
            <i class="fas fa-forward"></i> Auto Run
          </button>
        </div>
        <div class="btn-group">
          <button class="control-btn btn-secondary" id="resetBtn" disabled>
            <i class="fas fa-redo"></i> Reset
          </button>
          <button class="control-btn btn-secondary" id="clearBtn">
            <i class="fas fa-trash"></i> Clear
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="center-panel">
    <div class="graph-container">
      <div class="graph-visualization" id="graphVisualization">
        </div>
    </div>
    
    <div class="graph-controls">
      <button class="graph-control-btn" id="zoomInBtn">
        <i class="fas fa-search-plus"></i> Zoom In
        <span class="key-hint">[+]</span>
      </button>
      <button class="graph-control-btn" id="zoomOutBtn">
        <i class="fas fa-search-minus"></i> Zoom Out
        <span class="key-hint">[-]</span>
      </button>
      <button class="graph-control-btn" id="prevStepBtn" disabled>
        <i class="fas fa-arrow-left"></i> Previous
        <span class="key-hint">[←]</span>
      </button>
      <button class="graph-control-btn" id="nextStepBtn" disabled>
        <i class="fas fa-arrow-right"></i> Next
        <span class="key-hint">[→]</span>
      </button>
      <button class="graph-control-btn" id="centerViewBtn">
        <i class="fas fa-expand-arrows-alt"></i> Center
        <span class="key-hint">[C]</span>
      </button>
      <button class="graph-control-btn" id="toggleFlowBtn">
        <i class="fas fa-water"></i> Show Flow
        <span class="key-hint">[F]</span>
      </button>
      <button class="graph-control-btn" id="toggleMinCutBtn" disabled>
        <i class="fas fa-cut"></i> Min-Cut
        <span class="key-hint">[M]</span>
      </button>
    </div>
  </div>

  <div class="panel panel-right">
    <div class="panel-header">
      <div class="panel-title">Analysis & Results</div>
    </div>
    <div class="panel-content">
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-header">
            <span class="metric-name">Maximum Flow</span>
            <span class="metric-value" id="maxFlowValue">0</span>
          </div>
          <div class="metric-description">Total flow from source to sink</div>
        </div>

        <div class="metric-card">
          <div class="metric-header">
            <span class="metric-name">Augmenting Paths</span>
            <span class="metric-value" id="pathsValue">0</span>
          </div>
          <div class="metric-description">Number of BFS paths found</div>
        </div>

        <div class="metric-card">
          <div class="metric-header">
            <span class="metric-name">Execution Time</span>
            <span class="metric-value" id="timeValue">0ms</span>
          </div>
          <div class="metric-description">Algorithm runtime</div>
        </div>

        <div class="metric-card">
          <div class="metric-header">
            <span class="metric-name">Graph Density</span>
            <span class="metric-value" id="densityValue">0%</span>
          </div>
          <div class="metric-description">Edges / possible edges</div>
        </div>
      </div>

      <div class="min-cut-info" id="minCutInfo">
        <div class="min-cut-title">
          <i class="fas fa-cut"></i> Minimum Cut
        </div>
        <div class="min-cut-content">
          <p>Max-flow = Min-cut: <strong id="maxFlowEqualsMinCut">0 = 0</strong></p>
          <div class="min-cut-sets">
            <div class="min-cut-set">
              <div class="min-cut-set-label">Reachable from source:</div>
              <div class="min-cut-set-nodes" id="cutSetReachable"></div>
            </div>
            <div class="min-cut-set">
              <div class="min-cut-set-label">Not reachable:</div>
              <div class="min-cut-set-nodes" id="cutSetNonReachable"></div>
            </div>
          </div>
          <div class="min-cut-content" id="cutEdgesList"></div>
        </div>
      </div>

      <div class="input-section">
        <div class="section-title">
          <i class="fas fa-graduation-cap"></i> Algorithm Explanation
        </div>
        <div class="explanation-panel" id="explanationPanel">
          <div class="explanation-step active" data-step="0">
            <h4>Step 1: Initialize</h4>
            <p>Set all flows to 0. Create residual graph with capacities equal to original capacities.</p>
          </div>
          <div class="explanation-step" data-step="1">
            <h4>Step 2: Find Augmenting Path</h4>
            <p>Use BFS to find a path from source to sink in the residual graph where all edges have capacity > 0.</p>
          </div>
          <div class="explanation-step" data-step="2">
            <h4>Step 3: Find Bottleneck</h4>
            <p>Find the minimum capacity along the path. This determines how much flow we can add.</p>
          </div>
          <div class="explanation-step" data-step="3">
            <h4>Step 4: Augment Flow</h4>
            <p>Add flow along forward edges, subtract from reverse edges in residual graph.</p>
          </div>
          <div class="explanation-step" data-step="4">
            <h4>Step 5: Repeat</h4>
            <p>Continue finding augmenting paths until no more exist. The max-flow min-cut theorem guarantees optimality.</p>
          </div>
        </div>
      </div>

      <div class="input-section">
        <div class="section-title">
          <i class="fas fa-history"></i> Path History
        </div>
        <div class="path-history" id="pathHistory">
          <div style="text-align: center; color: var(--text-muted); padding: 2rem;">
            <i class="fas fa-route" style="font-size: 1.5rem; margin-bottom: 0.5rem; opacity: 0.5;"></i>
            <div>No augmenting paths found yet</div>
          </div>
        </div>
      </div>

      <div class="input-section">
        <div class="section-title">
          <i class="fas fa-terminal"></i> Execution Log
        </div>
        <div class="log-panel" id="logPanel">
          <div class="log-entry info">
            <span class="log-time">00:00</span>
            <span class="log-message">System initialized. Ready to visualize.</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-text" id="statusText">Ready to initialize graph</div>
    <div class="keyboard-shortcuts">
      <div class="shortcut">
        <kbd>Space</kbd>
        <span>Step forward</span>
      </div>
      <div class="shortcut">
        <kbd>A</kbd>
        <span>Auto run</span>
      </div>
      <div class="shortcut">
        <kbd>R</kbd>
        <span>Reset</span>
      </div>
      <div class="shortcut">
        <kbd>M</kbd>
        <span>Min-cut</span>
      </div>
    </div>
  </div>
</div>

<script>
// Main Application State
const state = {
  graph: {
    nodes: [],
    edges: [],
    adjList: new Map(),
    nodePositions: new Map()
  },
  residualGraph: new Map(),
  source: 0,
  sink: 3,
  maxFlow: 0,
  pathCount: 0,
  currentPath: null,
  isAnimating: false,
  zoomLevel: 1,
  initialized: false,
  layoutCalculated: false,
  startTime: 0,
  showFlow: true,
  stepHistory: [],
  currentStep: -1,
  showMinCut: false,
  minCut: {
    reachable: new Set(),
    cutEdges: [],
    totalCapacity: 0
  },
  algorithmComplete: false
};

// Presets Configuration
const presets = {
  simple: {
    name: "Simple Network",
    edges: `0 1 10
0 2 5
1 3 10
2 3 10`,
    source: 0,
    sink: 3,
    description: "Basic 4-node network"
  },
  medium: {
    name: "Medium Network",
    edges: `0 1 16
0 2 13
1 2 10
1 3 12
2 1 4
2 4 14
3 2 9
3 5 20
4 3 7
4 5 4`,
    source: 0,
    sink: 5,
    description: "Standard textbook example"
  },
  complex: {
    name: "Complex Network",
    edges: `0 1 10
0 2 10
1 2 2
1 3 4
1 4 8
2 4 9
3 5 10
4 3 6
4 5 10`,
    source: 0,
    sink: 5,
    description: "Network with multiple paths"
  },
  large: {
    name: "Large Network",
    edges: `0 1 10
0 2 12
0 3 8
1 4 9
1 5 7
2 5 11
2 6 8
3 6 10
4 7 6
5 7 8
5 8 9
6 8 7
7 9 10
8 9 12`,
    source: 0,
    sink: 9,
    description: "10-node complex network"
  }
};

// Initialize Application
function init() {
  setupEventListeners();
  loadPreset('simple');
  addLog("Visualizer initialized", "info");
  updateStatus("Ready to initialize graph");
}

// Event Listeners Setup
function setupEventListeners() {
  // Preset buttons
  document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', () => loadPreset(btn.dataset.preset));
  });
  
  // Control buttons
  document.getElementById('initBtn').addEventListener('click', initializeGraph);
  document.getElementById('stepBtn').addEventListener('click', fordFulkersonStep);
  document.getElementById('autoBtn').addEventListener('click', toggleAutoRun);
  document.getElementById('resetBtn').addEventListener('click', resetFlow);
  document.getElementById('clearBtn').addEventListener('click', clearAll);
  
  // Graph control buttons
  document.getElementById('zoomInBtn').addEventListener('click', () => zoom(1.2));
  document.getElementById('zoomOutBtn').addEventListener('click', () => zoom(0.8));
  document.getElementById('prevStepBtn').addEventListener('click', goToPreviousStep);
  document.getElementById('nextStepBtn').addEventListener('click', goToNextStep);
  document.getElementById('centerViewBtn').addEventListener('click', centerView);
  document.getElementById('toggleFlowBtn').addEventListener('click', toggleFlowDisplay);
  document.getElementById('toggleMinCutBtn').addEventListener('click', toggleMinCutDisplay);
  
  // Keyboard shortcuts
  document.addEventListener('keydown', handleKeyboardShortcut);
  
  // Input validation
  document.getElementById('graphInput').addEventListener('input', validateGraphInput);
  document.getElementById('sourceInput').addEventListener('input', validateNodeInput);
  document.getElementById('sinkInput').addEventListener('input', validateNodeInput);
}

// Keyboard Shortcuts
function handleKeyboardShortcut(e) {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  switch(e.key.toLowerCase()) {
    case ' ':
      if (state.initialized && !state.isAnimating && !state.algorithmComplete) fordFulkersonStep();
      e.preventDefault();
      break;
    case 'a':
      if (state.initialized && !state.algorithmComplete) toggleAutoRun();
      e.preventDefault();
      break;
    case 'r':
      if (state.initialized) resetFlow();
      e.preventDefault();
      break;
    case 'c':
      clearAll();
      e.preventDefault();
      break;
    case 'm':
      if (state.initialized && state.algorithmComplete) toggleMinCutDisplay();
      e.preventDefault();
      break;
    case '+':
    case '=':
      zoom(1.2);
      e.preventDefault();
      break;
    case '-':
    case '_':
      zoom(0.8);
      e.preventDefault();
      break;
    case 'arrowleft':
      if (state.initialized) goToPreviousStep();
      e.preventDefault();
      break;
    case 'arrowright':
      if (state.initialized) goToNextStep();
      e.preventDefault();
      break;
    case 'f':
      toggleFlowDisplay();
      e.preventDefault();
      break;
  }
}

// Input Validation
function validateGraphInput() {
  const input = document.getElementById('graphInput').value.trim();
  const lines = input.split('\n').filter(l => l.trim() !== '');
  
  // 1. Limit Check for Educational Purposes
  const uniqueNodes = new Set();
  lines.forEach(line => {
    const parts = line.trim().split(/\s+/);
    if(parts.length >= 2) {
      uniqueNodes.add(parts[0]);
      uniqueNodes.add(parts[1]);
    }
  });

  if (uniqueNodes.size > 10) {
    showToast("Educational Limit: Max 10 nodes allowed for clear visualization.", "warning");
    document.getElementById('graphInput').style.borderColor = 'var(--accent-warning)';
    return false;
  }
  if (lines.length > 15) {
    showToast("Educational Limit: Max 15 edges allowed for clear visualization.", "warning");
    document.getElementById('graphInput').style.borderColor = 'var(--accent-warning)';
    return false;
  }
  
  let isValid = true;
  let errorMessage = '';
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line === '') continue;
    
    const parts = line.split(/\s+/);
    if (parts.length !== 3) {
      isValid = false;
      errorMessage = `Line ${i + 1}: Expected 3 numbers (u v capacity)`;
      break;
    }
    
    const [u, v, cap] = parts.map(Number);
    if (isNaN(u) || isNaN(v) || isNaN(cap)) {
      isValid = false;
      errorMessage = `Line ${i + 1}: Invalid number format`;
      break;
    }
    
    if (cap < 0) {
      isValid = false;
      errorMessage = `Line ${i + 1}: Capacity cannot be negative`;
      break;
    }
    
    if (u === v) {
      isValid = false;
      errorMessage = `Line ${i + 1}: Self-loops are not allowed`;
      break;
    }
  }
  
  if (isValid) {
    document.getElementById('graphInput').style.borderColor = 'var(--border-medium)';
  } else {
    document.getElementById('graphInput').style.borderColor = 'var(--accent-error)';
  }
  
  return isValid;
}

function validateNodeInput() {
  const source = parseInt(document.getElementById('sourceInput').value);
  const sink = parseInt(document.getElementById('sinkInput').value);
  
  if (isNaN(source) || isNaN(sink)) {
    return false;
  }
  
  if (source === sink) {
    document.getElementById('sourceInput').style.borderColor = 'var(--accent-error)';
    document.getElementById('sinkInput').style.borderColor = 'var(--accent-error)';
    return false;
  }
  
  document.getElementById('sourceInput').style.borderColor = 'var(--border-medium)';
  document.getElementById('sinkInput').style.borderColor = 'var(--border-medium)';
  return true;
}

// Load Preset Network
function loadPreset(presetKey) {
  const preset = presets[presetKey];
  if (!preset) return;
  
  document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`[data-preset="${presetKey}"]`).classList.add('active');
  
  document.getElementById('graphInput').value = preset.edges;
  document.getElementById('sourceInput').value = preset.source;
  document.getElementById('sinkInput').value = preset.sink;
  
  addLog(`Loaded ${preset.name} preset`, "info");
  updateStatus(`Loaded ${preset.name}: ${preset.description}`);
  showToast(`Loaded ${preset.name} preset`, 'info');
}

// Initialize Graph from Input
function initializeGraph() {
  try {
    if (!validateGraphInput() || !validateNodeInput()) {
      throw new Error("Please fix the validation errors in the input fields");
    }
    
    const input = document.getElementById('graphInput').value.trim();
    state.source = parseInt(document.getElementById('sourceInput').value);
    state.sink = parseInt(document.getElementById('sinkInput').value);
    
    const parsed = parseGraph(input);
    state.graph.nodes = parsed.nodes;
    state.graph.edges = parsed.edges;
    
    // Validate source and sink
    if (!state.graph.nodes.find(n => n.id === state.source)) {
      throw new Error(`Source node ${state.source} not found in graph`);
    }
    if (!state.graph.nodes.find(n => n.id === state.sink)) {
      throw new Error(`Sink node ${state.sink} not found in graph`);
    }
    if (state.source === state.sink) {
      throw new Error("Source and sink cannot be the same node");
    }
    
    const { adjList, resGraph } = buildGraph(state.graph.nodes, state.graph.edges);
    state.graph.adjList = adjList;
    state.residualGraph = resGraph;
    
    // Reset Algorithm State (CRITICAL: Do not run BFS here)
    state.maxFlow = 0;
    state.pathCount = 0;
    state.currentPath = null;
    state.stepHistory = [];
    state.currentStep = -1;
    state.startTime = Date.now();
    state.initialized = true;
    state.layoutCalculated = false; // Reset layout
    state.zoomLevel = 1;
    state.showMinCut = false;
    state.algorithmComplete = false;
    
    // Save initial state to history
    saveStateToHistory();
    
    // Enable controls
    document.getElementById('stepBtn').disabled = false;
    document.getElementById('autoBtn').disabled = false;
    document.getElementById('resetBtn').disabled = false;
    document.getElementById('prevStepBtn').disabled = true;
    document.getElementById('nextStepBtn').disabled = true;
    document.getElementById('toggleMinCutBtn').disabled = true;
    
    // Hide min-cut info
    document.getElementById('minCutInfo').classList.remove('show');
    
    updateMetrics();
    clearPathHistory();
    addLog(`Graph initialized with ${state.graph.nodes.length} nodes and ${state.graph.edges.length} edges`, "success");
    updateStatus(`Graph ready • Source: ${state.source}, Sink: ${state.sink} • Press Space or click "Step" to begin`);
    showToast("Graph initialized successfully", 'success');
    updateExplanationStep(0); // Show "Step 1: Initialize" text
    
    renderGraph();
    
  } catch (error) {
    console.error(error);
    addLog(`Error: ${error.message}`, "error");
    updateStatus(`Error: ${error.message}`);
    showToast(`Error: ${error.message}`, 'error');
  }
}

// Parse Graph Input with enhanced validation
function parseGraph(text) {
  const lines = text.trim().split('\n');
  const edges = [];
  const nodeSet = new Set();
  const edgeMap = new Map();
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line === '') continue;
    
    const parts = line.split(/\s+/).map(Number);
    if (parts.length !== 3) {
      throw new Error(`Line ${i + 1}: Expected 3 numbers (u v capacity)`);
    }
    
    const [u, v, cap] = parts;
    
    // Validation
    if (cap < 0) {
      throw new Error(`Line ${i + 1}: Capacity cannot be negative`);
    }
    if (u === v) {
      throw new Error(`Line ${i + 1}: Self-loops are not allowed`);
    }
    if (cap === 0) {
      console.warn(`Edge ${u}->${v} has zero capacity`);
    }
    
    // Handle parallel edges by summing capacities
    const edgeId = `${u}-${v}`;
    if (edgeMap.has(edgeId)) {
      edgeMap.get(edgeId).capacity += cap;
      edgeMap.get(edgeId).originalCapacity += cap;
    } else {
      const edge = { 
        u, v, 
        capacity: cap, 
        flow: 0,
        id: edgeId,
        originalCapacity: cap
      };
      edges.push(edge);
      edgeMap.set(edgeId, edge);
    }
    
    nodeSet.add(u);
    nodeSet.add(v);
  }
  
  if (edges.length === 0) {
    throw new Error("No valid edges found in input");
  }
  
  // Create nodes with degree calculation
  const nodes = Array.from(nodeSet)
    .sort((a, b) => a - b)
    .map(id => ({ 
      id, 
      label: `Node ${id}`,
      degree: 0,
      inDegree: 0,
      outDegree: 0
    }));
    
  // Calculate degrees
  edges.forEach(edge => {
    const uNode = nodes.find(n => n.id === edge.u);
    const vNode = nodes.find(n => n.id === edge.v);
    if (uNode) {
      uNode.degree++;
      uNode.outDegree++;
    }
    if (vNode) {
      vNode.degree++;
      vNode.inDegree++;
    }
  });
  
  return { nodes, edges };
}

// Build Graph Structure
function buildGraph(nodes, edges) {
  const adjList = new Map();
  const resGraph = new Map();
  
  nodes.forEach(n => {
    adjList.set(n.id, []);
    resGraph.set(n.id, new Map());
  });
  
  edges.forEach(e => {
    adjList.get(e.u).push(e);
    // Initialize residual graph with forward and backward edges
    if (!resGraph.get(e.u).has(e.v)) {
      resGraph.get(e.u).set(e.v, e.capacity);
    }
    if (!resGraph.get(e.v).has(e.u)) {
      resGraph.get(e.v).set(e.u, 0);
    }
  });
  
  return { adjList, resGraph };
}

// Save current state to history
function saveStateToHistory() {
  // Limit history size
  if (state.stepHistory.length > 50) {
    state.stepHistory.shift();
    if (state.currentStep > 0) state.currentStep--;
  }
  
  const historyState = {
    maxFlow: state.maxFlow,
    pathCount: state.pathCount,
    currentPath: state.currentPath ? [...state.currentPath] : null,
    // Store simple edge flows instead of deep cloning full objects
    edgeFlows: state.graph.edges.map(e => ({id: e.id, flow: e.flow})),
    residualGraph: serializeMap(state.residualGraph),
    algorithmComplete: state.algorithmComplete
  };
  
  state.stepHistory = state.stepHistory.slice(0, state.currentStep + 1);
  state.stepHistory.push(historyState);
  state.currentStep++;
}

// Serialize Map for history storage
function serializeMap(map) {
  const obj = {};
  for (const [key, value] of map.entries()) {
    if (value instanceof Map) {
      obj[key] = serializeMap(value);
    } else {
      obj[key] = value;
    }
  }
  return obj;
}

// Deserialize Map from history
function deserializeMap(obj) {
  const map = new Map();
  for (const key in obj) {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      map.set(Number(key), deserializeMap(obj[key]));
    } else {
      map.set(Number(key), obj[key]);
    }
  }
  return map;
}

// Restore state from history
function restoreStateFromHistory(stepIndex) {
  if (stepIndex < 0 || stepIndex >= state.stepHistory.length) return;
  
  const historyState = state.stepHistory[stepIndex];
  
  state.maxFlow = historyState.maxFlow;
  state.pathCount = historyState.pathCount;
  state.currentPath = historyState.currentPath ? [...historyState.currentPath] : null;
  
  // Restore edge flows in place
  if (historyState.edgeFlows) {
    historyState.edgeFlows.forEach(ef => {
      const edge = state.graph.edges.find(e => e.id === ef.id);
      if (edge) edge.flow = ef.flow;
    });
  }
  
  state.residualGraph = deserializeMap(historyState.residualGraph);
  state.algorithmComplete = historyState.algorithmComplete;
  
  state.currentStep = stepIndex;
}

// REPLACEMENT: Deterministic Grid Layout System (The "Chessboard" Logic)
function computeGridLayout(nodes, edges, sourceId, sinkId) {
  const width = 1000;
  const height = 600;
  const paddingX = 100; // Left/Right padding
  const sourceX = paddingX;
  const sinkX = width - paddingX;

  // 1. Initialize BFS to determine "Layers" (Distance from Source)
  const layers = new Map();
  const visited = new Set();
  const queue = [{ id: sourceId, dist: 0 }];

  visited.add(sourceId);
  layers.set(sourceId, 0);

  // Run BFS to assign layers
  while (queue.length > 0) {
    const { id, dist } = queue.shift();
    
    // Find neighbors
    const neighbors = edges
      .filter(e => e.u === id)
      .map(e => e.v);

    for (const neighborId of neighbors) {
      if (!visited.has(neighborId)) {
        visited.add(neighborId);
        layers.set(neighborId, dist + 1);
        queue.push({ id: neighborId, dist: dist + 1 });
      }
    }
  }

  // 2. Handle Disconnected Nodes & Sink Special Case
  nodes.forEach(node => {
    if (node.id === sinkId) return; // Skip sink for now
    if (!layers.has(node.id)) {
      // If node is unreachable, put it in a "middle" layer but lower down
      layers.set(node.id, 1); 
    }
  });

  // 3. Group Nodes by Layer
  const layerGroups = [];
  layers.forEach((dist, id) => {
    if (id === sinkId) return; // Don't group sink yet
    if (!layerGroups[dist]) layerGroups[dist] = [];
    layerGroups[dist].push(id);
  });

  // Filter out empty slots
  const cleanLayers = layerGroups.filter(g => g && g.length > 0);

  // 4. Calculate X-Positions (Columns)
  // We have (cleanLayers.length) intermediate columns + Sink
  const totalColumns = cleanLayers.length + 1; // +1 for Sink
  const xStep = (sinkX - sourceX) / totalColumns;

  // 5. Assign Coordinates
  nodes.forEach(node => {
    // Case A: Source (Fixed Left)
    if (node.id === sourceId) {
      node.x = sourceX;
      node.y = height / 2;
      return;
    }

    // Case B: Sink (Fixed Right)
    if (node.id === sinkId) {
      node.x = sinkX;
      node.y = height / 2;
      return;
    }

    // Case C: Intermediate Nodes
    const layerIndex = layers.get(node.id);
    const nodesInThisLayer = layerGroups[layerIndex];
    
    // Sort nodes in layer by ID to ensure consistent vertical ordering
    nodesInThisLayer.sort((a, b) => a - b);
    
    const nodeIndex = nodesInThisLayer.indexOf(node.id);
    const count = nodesInThisLayer.length;

    // Calculate X
    node.x = sourceX + (layerIndex * xStep);

    // Calculate Y (Vertical Centering)
    // Divide height into (count + 1) segments
    const segmentHeight = height / (count + 1);
    let yPos = segmentHeight * (nodeIndex + 1);

    // Apply "Chessboard Stagger"
    // Shift odd columns slightly down, even columns slightly up
    // This prevents straight horizontal lines overlapping text
    const staggerOffset = 40; 
    if (layerIndex % 2 !== 0) {
        yPos += staggerOffset;
    } else {
        yPos -= staggerOffset;
    }
    
    // Clamp Y to safe area
    node.y = Math.max(80, Math.min(height - 80, yPos));
  });

  return nodes;
}

// Ford-Fulkerson Algorithm Implementation
function bfs(resGraph, source, sink) {
  const visited = new Set([source]);
  const queue = [{ node: source, parent: null }];
  const parent = new Map();
  
  while (queue.length > 0) {
    const { node } = queue.shift();
    
    if (node === sink) {
      // Reconstruct path
      const path = [];
      let current = sink;
      while (current !== null) {
        path.unshift(current);
        current = parent.get(current);
      }
      return path;
    }
    
    const neighbors = resGraph.get(node);
    if (!neighbors) continue;
    
    for (const [next, capacity] of neighbors) {
      if (!visited.has(next) && capacity > 0) {
        visited.add(next);
        parent.set(next, node);
        queue.push({ node: next, parent: node });
      }
    }
  }
  
  return null;
}

function getBottleneck(path, resGraph) {
  let minCapacity = Infinity;
  for (let i = 0; i < path.length - 1; i++) {
    const u = path[i];
    const v = path[i + 1];
    const capacity = resGraph.get(u)?.get(v) || 0;
    if (capacity < minCapacity) {
      minCapacity = capacity;
    }
  }
  return minCapacity;
}

function augmentPath(path, bottleneck) {
  for (let i = 0; i < path.length - 1; i++) {
    const u = path[i];
    const v = path[i + 1];
    
    // Update residual graph
    const forwardCapacity = state.residualGraph.get(u)?.get(v) || 0;
    const backwardCapacity = state.residualGraph.get(v)?.get(u) || 0;
    
    state.residualGraph.get(u).set(v, forwardCapacity - bottleneck);
    state.residualGraph.get(v).set(u, backwardCapacity + bottleneck);
    
    // Update flow in original graph
    const edge = state.graph.edges.find(e => e.u === u && e.v === v);
    if (edge) {
      edge.flow += bottleneck;
    } else {
      // This is a reverse edge in residual graph
      const reverseEdge = state.graph.edges.find(e => e.u === v && e.v === u);
      if (reverseEdge) {
        reverseEdge.flow -= bottleneck;
      }
    }
  }
}

function findMinCut() {
  state.minCut.reachable = new Set([state.source]);
  const queue = [state.source];
  
  while (queue.length > 0) {
    const u = queue.shift();
    const neighbors = state.residualGraph.get(u);
    
    if (neighbors) {
      for (const [v, capacity] of neighbors) {
        if (capacity > 0 && !state.minCut.reachable.has(v)) {
          state.minCut.reachable.add(v);
          queue.push(v);
        }
      }
    }
  }
  
  // Find cut edges and calculate total capacity
  state.minCut.cutEdges = [];
  state.minCut.totalCapacity = 0;
  
  state.graph.edges.forEach(edge => {
    if (state.minCut.reachable.has(edge.u) && 
        !state.minCut.reachable.has(edge.v) && 
        edge.originalCapacity > 0) {
      state.minCut.cutEdges.push({
        id: edge.id,
        u: edge.u,
        v: edge.v,
        capacity: edge.originalCapacity
      });
      state.minCut.totalCapacity += edge.originalCapacity;
    }
  });
  
  return state.minCut.cutEdges.length > 0;
}

function updateMinCutDisplay() {
  const minCutInfo = document.getElementById('minCutInfo');
  const cutSetReachable = document.getElementById('cutSetReachable');
  const cutSetNonReachable = document.getElementById('cutSetNonReachable');
  const cutEdgesList = document.getElementById('cutEdgesList');
  const maxFlowEqualsMinCut = document.getElementById('maxFlowEqualsMinCut');
  
  if (!state.minCut.reachable.size) {
    minCutInfo.classList.remove('show');
    return;
  }
  
  // Update max-flow = min-cut equation
  maxFlowEqualsMinCut.textContent = `${state.maxFlow} = ${state.minCut.totalCapacity}`;
  
  // Update reachable set
  const reachableNodes = Array.from(state.minCut.reachable).sort((a, b) => a - b);
  cutSetReachable.textContent = reachableNodes.join(', ');
  
  // Update non-reachable set
  const nonReachableNodes = state.graph.nodes
    .map(n => n.id)
    .filter(id => !state.minCut.reachable.has(id))
    .sort((a, b) => a - b);
  cutSetNonReachable.textContent = nonReachableNodes.join(', ');
  
  // Update cut edges list
  cutEdgesList.innerHTML = '<p>Cut edges:</p>';
  state.minCut.cutEdges.forEach(edge => {
    const edgeItem = document.createElement('div');
    edgeItem.className = 'cut-edge-item';
    edgeItem.innerHTML = `
      <span>${edge.u} → ${edge.v}</span>
      <span style="color: var(--accent-error); font-weight: bold;">${edge.capacity}</span>
    `;
    cutEdgesList.appendChild(edgeItem);
  });
  
  if (state.showMinCut) {
    minCutInfo.classList.add('show');
  }
}

function fordFulkersonStep() {
  console.log('=== STEP START ===');
  console.log('State:', {
    initialized: state.initialized,
    animating: state.isAnimating,
    complete: state.algorithmComplete,
    currentStep: state.currentStep,
    historyLength: state.stepHistory.length
  });

  if (!state.initialized || (state.isAnimating && !state.isAnimating) || state.algorithmComplete) return false;
  
  try {
    updateExplanationStep(1); // Show step 2 explanation
    
    if (!state.residualGraph || state.residualGraph.size === 0) {
      console.error('Residual graph not initialized');
      addLog('Residual graph error - please reinitialize', 'error');
      return false;
    }

    const path = bfs(state.residualGraph, state.source, state.sink);
    console.log('BFS result:', path);
    
    if (!path) {
      // Algorithm complete - find min-cut
      findMinCut();
      updateExplanationStep(4); // Show step 5 explanation
      
      addLog("No more augmenting paths found. Algorithm complete!", "success");
      updateStatus(`Algorithm complete! Maximum flow: ${state.maxFlow}`);
      document.getElementById('stepBtn').disabled = true;
      document.getElementById('autoBtn').disabled = true;
      document.getElementById('toggleMinCutBtn').disabled = false;
      state.algorithmComplete = true;
      state.currentPath = null;
      
      // Save final state to history
      saveStateToHistory();
      
      showToast(`Algorithm complete! Maximum flow: ${state.maxFlow}`, 'success');
      
      // Render graph to clear active path
      renderGraph();
      return false;
    }
    
    updateExplanationStep(2); // Show step 3 explanation
    
    const bottleneck = getBottleneck(path, state.residualGraph);
    console.log('Bottleneck:', bottleneck);
    
    if (bottleneck <= 0) {
      addLog("Found path with zero bottleneck capacity", "warning");
      return false;
    }
    
    updateExplanationStep(3); // Show step 4 explanation
    
    // Apply augmentation
    augmentPath(path, bottleneck);
    state.maxFlow += bottleneck;
    state.pathCount++;
    state.currentPath = path; // Updated active path
    
    console.log('After augmentation:', {
       maxFlow: state.maxFlow,
       pathCount: state.pathCount,
       currentPath: state.currentPath
    });

    // Update UI
    updateMetrics();
    addPathToHistory(path, bottleneck);
    addLog(`Path ${state.pathCount}: ${path.join(' → ')} | Flow: ${bottleneck}`, "success");
    updateStatus(`Found augmenting path ${state.pathCount} with flow ${bottleneck}`);
    
    // Save current state to history WITH the new path active
    saveStateToHistory();
    
    // Update navigation buttons
    updateNavigationButtons();
    
    // Visualize
    renderGraph();
    
    updateExplanationStep(0); // Reset to step 1 for next iteration
    
    return true;
  } catch (error) {
    console.error('Error in fordFulkersonStep:', error);
    addLog(`Error during step: ${error.message}`, "error");
    showToast(`Error: ${error.message}`, "error");
    state.isAnimating = false;
    return false;
  }
}

async function toggleAutoRun() {
  const autoBtn = document.getElementById('autoBtn');
  
  if (state.isAnimating) {
    state.isAnimating = false;
    autoBtn.innerHTML = '<i class="fas fa-forward"></i> Auto Run';
    addLog("Auto-run stopped", "warning");
    showToast("Auto-run stopped", 'warning');
    return;
  }
  
  if (!state.initialized || state.algorithmComplete) return;
  
  state.isAnimating = true;
  autoBtn.innerHTML = '<i class="fas fa-stop"></i> Stop';
  document.getElementById('stepBtn').disabled = true;
  
  let stepCounter = 0;
  const MAX_STEPS = 100; // Safety limit
  
  try {
    while (state.isAnimating && stepCounter < MAX_STEPS) {
       const hasNextStep = fordFulkersonStep();
       if (!hasNextStep) break;
       
       stepCounter++;
       await new Promise(resolve => setTimeout(resolve, 1500));
    }
  } catch (e) {
    console.error("Auto run error", e);
  } finally {
    if (stepCounter >= MAX_STEPS) {
      addLog(`Auto-run stopped: reached maximum ${MAX_STEPS} iterations`, "warning");
      showToast("Maximum iterations reached", "warning");
    }
    
    state.isAnimating = false;
    autoBtn.innerHTML = '<i class="fas fa-forward"></i> Auto Run';
    document.getElementById('stepBtn').disabled = state.algorithmComplete;
  }
}

function resetFlow() {
  if (!state.initialized) return;
  
  state.graph.edges.forEach(e => e.flow = 0);
  const { resGraph } = buildGraph(state.graph.nodes, state.graph.edges);
  state.residualGraph = resGraph;
  
  state.maxFlow = 0;
  state.pathCount = 0;
  state.currentPath = null;
  state.stepHistory = [];
  state.currentStep = -1;
  state.startTime = Date.now();
  state.showMinCut = false;
  state.algorithmComplete = false;
  state.minCut = {
    reachable: new Set(),
    cutEdges: [],
    totalCapacity: 0
  };
  
  // Save initial state
  saveStateToHistory();
  
  document.getElementById('stepBtn').disabled = false;
  document.getElementById('autoBtn').disabled = false;
  document.getElementById('prevStepBtn').disabled = true;
  document.getElementById('nextStepBtn').disabled = true;
  document.getElementById('toggleMinCutBtn').disabled = true;
  document.getElementById('minCutInfo').classList.remove('show');
  
  updateMetrics();
  clearPathHistory();
  addLog("Flow reset to zero", "warning");
  updateStatus("Flow reset • Ready to run algorithm again");
  showToast("Flow reset to zero", 'warning');
  updateExplanationStep(0);
  
  renderGraph();
}

function clearAll() {
  state.graph = {
    nodes: [],
    edges: [],
    adjList: new Map(),
    nodePositions: new Map()
  };
  state.residualGraph = new Map();
  state.maxFlow = 0;
  state.pathCount = 0;
  state.currentPath = null;
  state.isAnimating = false;
  state.initialized = false;
  state.layoutCalculated = false;
  state.zoomLevel = 1;
  state.stepHistory = [];
  state.currentStep = -1;
  state.showMinCut = false;
  state.algorithmComplete = false;
  state.minCut = {
    reachable: new Set(),
    cutEdges: [],
    totalCapacity: 0
  };
  
  document.getElementById('stepBtn').disabled = true;
  document.getElementById('autoBtn').disabled = true;
  document.getElementById('resetBtn').disabled = true;
  document.getElementById('prevStepBtn').disabled = true;
  document.getElementById('nextStepBtn').disabled = true;
  document.getElementById('toggleMinCutBtn').disabled = true;
  document.getElementById('autoBtn').innerHTML = '<i class="fas fa-forward"></i> Auto Run';
  document.getElementById('minCutInfo').classList.remove('show');
  
  updateMetrics();
  clearPathHistory();
  clearLog();
  addLog("All data cleared", "info");
  updateStatus("Ready to visualize • Click 'Initialize Graph' to begin");
  updateExplanationStep(0);
  showToast("All data cleared", 'info');
  
  // Clear graph visualization
  const graphVis = document.getElementById('graphVisualization');
  graphVis.innerHTML = '';
}

// Graph Navigation Functions
function goToPreviousStep() {
  if (state.currentStep <= 0 || !state.initialized) return;
  
  const newStep = state.currentStep - 1;
  restoreStateFromHistory(newStep);
  
  // Update UI
  updateMetrics();
  updateNavigationButtons();
  renderGraph();
  
  addLog(`Step ${state.currentStep + 1}: Reverted to previous step`, "info");
  updateStatus(`Step ${state.currentStep + 1} of ${state.stepHistory.length}`);
}

function goToNextStep() {
  if (state.currentStep >= state.stepHistory.length - 1 || !state.initialized) return;
  
  const newStep = state.currentStep + 1;
  restoreStateFromHistory(newStep);
  
  // Update UI
  updateMetrics();
  updateNavigationButtons();
  renderGraph();
  
  addLog(`Step ${state.currentStep + 1}: Advanced to next step`, "info");
  updateStatus(`Step ${state.currentStep + 1} of ${state.stepHistory.length}`);
}

function updateNavigationButtons() {
  document.getElementById('prevStepBtn').disabled = state.currentStep <= 0;
  document.getElementById('nextStepBtn').disabled = state.currentStep >= state.stepHistory.length - 1;
}

function zoom(factor) {
  const graphVis = document.getElementById('graphVisualization');
  state.zoomLevel *= factor;
  state.zoomLevel = Math.max(0.5, Math.min(2, state.zoomLevel));
  graphVis.style.transform = `scale(${state.zoomLevel})`;
}

function centerView() {
  const graphVis = document.getElementById('graphVisualization');
  const container = graphVis.parentElement;
  
  graphVis.style.transform = `scale(1)`;
  graphVis.style.transformOrigin = 'center';
  state.zoomLevel = 1;
  
  // Center the view
  container.scrollLeft = (graphVis.scrollWidth - container.clientWidth) / 2;
  container.scrollTop = (graphVis.scrollHeight - container.clientHeight) / 2;
}

function toggleFlowDisplay() {
  state.showFlow = !state.showFlow;
  const toggleBtn = document.getElementById('toggleFlowBtn');
  
  if (state.showFlow) {
    toggleBtn.innerHTML = '<i class="fas fa-water"></i> Show Flow';
    addLog("Showing flow values", "info");
  } else {
    toggleBtn.innerHTML = '<i class="fas fa-exchange-alt"></i> Show Residual';
    addLog("Showing residual capacities", "info");
  }
  
  renderGraph();
}

function toggleMinCutDisplay() {
  if (!state.algorithmComplete) return;
  
  state.showMinCut = !state.showMinCut;
  const minCutInfo = document.getElementById('minCutInfo');
  const toggleBtn = document.getElementById('toggleMinCutBtn');
  
  if (state.showMinCut) {
    toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i> Hide Cut';
    updateMinCutDisplay();
    minCutInfo.classList.add('show');
    addLog("Showing min-cut visualization", "info");
    showToast("Showing minimum cut visualization", 'info');
  } else {
    toggleBtn.innerHTML = '<i class="fas fa-cut"></i> Min-Cut';
    minCutInfo.classList.remove('show');
    addLog("Hiding min-cut visualization", "info");
  }
  
  renderGraph();
}

// Graph Rendering Functions
function renderGraph() {
  const graphVis = document.getElementById('graphVisualization');
  graphVis.innerHTML = '';
  
  if (!state.initialized || state.graph.nodes.length === 0) {
    graphVis.innerHTML = `
      <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">
        <i class="fas fa-project-diagram" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i>
        <div style="font-size: 1.1rem; font-weight: 500; margin-bottom: 0.5rem;">No Graph Loaded</div>
        <div style="font-size: 0.9rem; text-align: center;">Click "Initialize Graph" to visualize your network</div>
      </div>
    `;
    return;
  }
  
  // Determine Layout: Use Intelligent Grid Layout
  // Replaces the old forceDirectedLayout for deterministic results
  if (!state.layoutCalculated) {
    state.graph.nodes = computeGridLayout(state.graph.nodes, state.graph.edges, state.source, state.sink);
    state.layoutCalculated = true;
  }
  
  // Create SVG container
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');
  svg.setAttribute('viewBox', '0 0 1000 600');
  
  // Add definitions for gradients
  const defs = document.createElementNS(svgNS, "defs");
  
  // Source node gradient
  const sourceGradient = document.createElementNS(svgNS, "linearGradient");
  sourceGradient.setAttribute('id', 'sourceGradient');
  sourceGradient.setAttribute('x1', '0%');
  sourceGradient.setAttribute('y1', '0%');
  sourceGradient.setAttribute('x2', '100%');
  sourceGradient.setAttribute('y2', '100%');
  
  const sourceStop1 = document.createElementNS(svgNS, "stop");
  sourceStop1.setAttribute('offset', '0%');
  sourceStop1.setAttribute('stop-color', '#10b981');
  sourceGradient.appendChild(sourceStop1);
  
  const sourceStop2 = document.createElementNS(svgNS, "stop");
  sourceStop2.setAttribute('offset', '100%');
  sourceStop2.setAttribute('stop-color', '#059669');
  sourceGradient.appendChild(sourceStop2);
  
  // Sink node gradient
  const sinkGradient = document.createElementNS(svgNS, "linearGradient");
  sinkGradient.setAttribute('id', 'sinkGradient');
  sinkGradient.setAttribute('x1', '0%');
  sinkGradient.setAttribute('y1', '0%');
  sinkGradient.setAttribute('x2', '100%');
  sinkGradient.setAttribute('y2', '100%');
  
  const sinkStop1 = document.createElementNS(svgNS, "stop");
  sinkStop1.setAttribute('offset', '0%');
  sinkStop1.setAttribute('stop-color', '#ef4444');
  sinkGradient.appendChild(sinkStop1);
  
  const sinkStop2 = document.createElementNS(svgNS, "stop");
  sinkStop2.setAttribute('offset', '100%');
  sinkStop2.setAttribute('stop-color', '#dc2626');
  sinkGradient.appendChild(sinkStop2);
  
  // Regular node gradient
  const nodeGradient = document.createElementNS(svgNS, "linearGradient");
  nodeGradient.setAttribute('id', 'nodeGradient');
  nodeGradient.setAttribute('x1', '0%');
  nodeGradient.setAttribute('y1', '0%');
  nodeGradient.setAttribute('x2', '100%');
  nodeGradient.setAttribute('y2', '100%');
  
  const nodeStop1 = document.createElementNS(svgNS, "stop");
  nodeStop1.setAttribute('offset', '0%');
  nodeStop1.setAttribute('stop-color', '#3b82f6');
  nodeGradient.appendChild(nodeStop1);
  
  const nodeStop2 = document.createElementNS(svgNS, "stop");
  nodeStop2.setAttribute('offset', '100%');
  nodeStop2.setAttribute('stop-color', '#6366f1');
  nodeGradient.appendChild(nodeStop2);
  
  defs.appendChild(sourceGradient);
  defs.appendChild(sinkGradient);
  defs.appendChild(nodeGradient);
  svg.appendChild(defs);
  
  // Draw edges first (so they appear behind nodes)
  state.graph.edges.forEach(edge => {
    const u = state.graph.nodes.find(n => n.id === edge.u);
    const v = state.graph.nodes.find(n => n.id === edge.v);
    
    if (u && v) {
      const edgeElement = createEdgeElement(u, v, edge);
      svg.appendChild(edgeElement);
    }
  });
  
  // Draw nodes
  state.graph.nodes.forEach(node => {
    const nodeElement = createNodeElement(node);
    svg.appendChild(nodeElement);
  });
  
  // Draw edge labels (on top of everything)
  state.graph.edges.forEach(edge => {
    const u = state.graph.nodes.find(n => n.id === edge.u);
    const v = state.graph.nodes.find(n => n.id === edge.v);
    
    if (u && v) {
      const labelElement = createEdgeLabel(u, v, edge);
      svg.appendChild(labelElement);
    }
  });
  
  graphVis.appendChild(svg);
}

function createNodeElement(node) {
  const svgNS = "http://www.w3.org/2000/svg";
  const isSource = node.id === state.source;
  const isSink = node.id === state.sink;
  const isInPath = state.currentPath && state.currentPath.includes(node.id);
  const isInReachableSet = state.minCut.reachable.has(node.id);
  
  // Calculate node size based on degree
  const baseSize = 25;
  const degreeFactor = Math.log2(node.degree + 1);
  const nodeSize = Math.max(baseSize, Math.min(40, baseSize * (1 + degreeFactor * 0.3)));
  
  // Create group for node
  const group = document.createElementNS(svgNS, "g");
  
  // Node glow for active nodes in path
  if (isInPath) {
    const glow = document.createElementNS(svgNS, "circle");
    glow.setAttribute('cx', node.x);
    glow.setAttribute('cy', node.y);
    glow.setAttribute('r', nodeSize + 10);
    glow.setAttribute('fill', isSource ? 'rgba(16, 185, 129, 0.1)' : 
                               isSink ? 'rgba(239, 68, 68, 0.1)' : 
                               'rgba(59, 130, 246, 0.1)');
    group.appendChild(glow);
  }
  
  // Node circle
  const circle = document.createElementNS(svgNS, "circle");
  circle.setAttribute('cx', node.x);
  circle.setAttribute('cy', node.y);
  circle.setAttribute('r', nodeSize);
  
  // Determine node color based on min-cut visualization
  if (state.showMinCut && state.algorithmComplete) {
    if (isInReachableSet) {
      circle.setAttribute('class', 'node cut-side');
    } else {
      circle.setAttribute('class', 'node non-cut-side');
    }
    
    if (isSource) {
      circle.setAttribute('fill', 'url(#sourceGradient)');
    } else if (isSink) {
      circle.setAttribute('fill', 'url(#sinkGradient)');
    } else {
      circle.setAttribute('fill', 'url(#nodeGradient)');
    }
  } else {
    if (isSource) {
      circle.setAttribute('fill', 'url(#sourceGradient)');
    } else if (isSink) {
      circle.setAttribute('fill', 'url(#sinkGradient)');
    } else {
      circle.setAttribute('fill', 'url(#nodeGradient)');
    }
  }
  
  circle.setAttribute('stroke', isInPath ? '#ffffff' : 'rgba(255, 255, 255, 0.3)');
  circle.setAttribute('stroke-width', '2');
  group.appendChild(circle);
  
  // Node label
  const text = document.createElementNS(svgNS, "text");
  text.setAttribute('x', node.x);
  text.setAttribute('y', node.y);
  text.setAttribute('text-anchor', 'middle');
  text.setAttribute('dominant-baseline', 'middle');
  text.setAttribute('fill', '#ffffff');
  text.setAttribute('font-weight', 'bold');
  text.setAttribute('font-size', '16');
  text.textContent = node.id;
  group.appendChild(text);
  
  // Node degree label
  const degreeText = document.createElementNS(svgNS, "text");
  degreeText.setAttribute('x', node.x);
  degreeText.setAttribute('y', node.y + nodeSize + 15);
  degreeText.setAttribute('text-anchor', 'middle');
  degreeText.setAttribute('fill', 'var(--text-muted)');
  degreeText.setAttribute('font-size', '10');
  degreeText.textContent = `deg: ${node.degree}`;
  group.appendChild(degreeText);
  
  return group;
}

// REPLACEMENT: createEdgeElement (Correct Tangent Arrows)
function createEdgeElement(u, v, edge) {
  const svgNS = "http://www.w3.org/2000/svg";
  const isInPath = state.currentPath && 
    state.currentPath.some((node, i) => 
      i < state.currentPath.length - 1 && 
      node === edge.u && 
      state.currentPath[i + 1] === edge.v
    );
  
  const isCutEdge = state.showMinCut && state.minCut.cutEdges.some(e => e.id === edge.id);
  
  const group = document.createElementNS(svgNS, "g");
  
  // Curve Control Point
  const midX = (u.x + v.x) / 2;
  const midY = (u.y + v.y) / 2;
  const dx = v.x - u.x;
  const dy = v.y - u.y;
  const len = Math.sqrt(dx*dx + dy*dy);
  const offset = Math.min(50, len * 0.2);
  const perpX = -dy / len;
  const perpY = dx / len;
  const controlX = midX + perpX * offset;
  const controlY = midY + perpY * offset;
  
  // Draw Path
  const path = document.createElementNS(svgNS, "path");
  const pathData = `M ${u.x} ${u.y} Q ${controlX} ${controlY} ${v.x} ${v.y}`;
  path.setAttribute('d', pathData);
  path.setAttribute('fill', 'none');
  
  // Styling
  let strokeColor, strokeWidth;
  if (isCutEdge) {
    strokeColor = '#ef4444';
    strokeWidth = 4;
    path.setAttribute('stroke-dasharray', '5,5');
    path.setAttribute('class', 'edge-line cut-edge');
  } else if (isInPath) {
    strokeColor = '#10b981';
    strokeWidth = 4;
    path.setAttribute('stroke-dasharray', '10,5');
    path.setAttribute('class', 'edge-line active');
    path.style.animation = 'flow 2s linear infinite';
  } else if (edge.flow > 0) {
    strokeColor = '#3b82f6';
    strokeWidth = Math.max(2, Math.min(4, edge.flow / edge.capacity * 3 + 2));
  } else {
    strokeColor = '#cbd5e1';
    strokeWidth = 2;
  }
  
  path.setAttribute('stroke', strokeColor);
  path.setAttribute('stroke-width', strokeWidth);
  path.setAttribute('stroke-linecap', 'round');
  group.appendChild(path);
  
  // Arrow Head Calculation (Tangent at t=1)
  // B'(1) = 2(P2 - P1) where P2 is target(v), P1 is control
  const tangentX = 2 * (v.x - controlX);
  const tangentY = 2 * (v.y - controlY);
  const tangentLen = Math.sqrt(tangentX*tangentX + tangentY*tangentY) || 1;
  
  // Normalize tangent
  const nx = tangentX / tangentLen;
  const ny = tangentY / tangentLen;
  
  // Position arrow back from node surface (assume radius ~35px)
  const arrowX = v.x - nx * 35;
  const arrowY = v.y - ny * 35;
  
  // Angle is direction of tangent
  const angle = Math.atan2(ny, nx);
  
  const arrowLength = 12;
  const arrowAngle = Math.PI / 6;
  
  const arrow = document.createElementNS(svgNS, "path");
  const arrowPath = `
    M ${arrowX} ${arrowY}
    L ${arrowX - arrowLength * Math.cos(angle - arrowAngle)} ${arrowY - arrowLength * Math.sin(angle - arrowAngle)}
    L ${arrowX - arrowLength * Math.cos(angle + arrowAngle)} ${arrowY - arrowLength * Math.sin(angle + arrowAngle)}
    Z
  `;
  arrow.setAttribute('d', arrowPath);
  arrow.setAttribute('fill', strokeColor);
  group.appendChild(arrow);
  
  return group;
}
// Updated createEdgeLabel with Better Positioning & Collision Detection
// REPLACEMENT: createEdgeLabel (Advanced Collision & Positioning)
function createEdgeLabel(u, v, edge) {
  const svgNS = "http://www.w3.org/2000/svg";
  
  // 1. Calculate Curve Geometry
  const midX = (u.x + v.x) / 2;
  const midY = (u.y + v.y) / 2;
  const dx = v.x - u.x;
  const dy = v.y - u.y;
  const len = Math.sqrt(dx*dx + dy*dy) || 1;
  
  // Curve control point
  const curveOffset = Math.min(50, len * 0.2);
  const perpX = -dy / len;
  const perpY = dx / len;
  const cx = midX + perpX * curveOffset;
  const cy = midY + perpY * curveOffset;
  
  // 2. Initial Label Position (t=0.5 on Quadratic Bezier)
  let labelX = 0.25 * u.x + 0.5 * cx + 0.25 * v.x;
  let labelY = 0.25 * u.y + 0.5 * cy + 0.25 * v.y;
  
  // 3. Global Node Collision Detection
  let collisionDetected = false;
  let pushDirection = { x: perpX, y: perpY };
  
  state.graph.nodes.forEach(node => {
    // Check distance to center of label
    const dist = Math.sqrt(Math.pow(labelX - node.x, 2) + Math.pow(labelY - node.y, 2));
    
    // If label is within 55px of ANY node (node radius ~25-40 + buffer), push it
    if (dist < 55) {
      collisionDetected = true;
      const awayX = labelX - node.x;
      const awayY = labelY - node.y;
      const awayLen = Math.sqrt(awayX*awayX + awayY*awayY) || 1;
      
      // Add weighted push vector away from this node
      pushDirection.x += (awayX / awayLen) * 0.8;
      pushDirection.y += (awayY / awayLen) * 0.8;
    }
  });
  
  if (collisionDetected) {
      const pushLen = Math.sqrt(pushDirection.x*pushDirection.x + pushDirection.y*pushDirection.y) || 1;
      // Push aggressively (35px) to clear the node
      labelX += (pushDirection.x / pushLen) * 35;
      labelY += (pushDirection.y / pushLen) * 35;
  }
  
  // 4. Handle Bidirectional & Parallel Edges
  const reverseEdge = state.graph.edges.find(e => e.u === v.id && e.v === u.id);
  
  if (reverseEdge) {
      // Bidirectional: Push to RIGHT side relative to direction
      const isForward = edge.id < reverseEdge.id ? 1 : -1; 
      // Note: We use edge ID comparison for consistency. 
      // Actually, standardizing on pushing "Right" relative to vector u->v is better visually.
      // Right vector is (dy, -dx). Our perp is (-dy, dx). So perp is "Left".
      // We want to push "Right" -> -perp.
      
      // Let's stick to the prompt's logic but refine direction
      // If we simply push along +perp for one and -perp for other based on ID sort
      if (edge.id < reverseEdge.id) {
          labelX += perpX * 25;
          labelY += perpY * 25;
      } else {
          labelX -= perpX * 25;
          labelY -= perpY * 25;
      }
  } else {
      // Parallel edges (same direction)
      const parallelEdges = state.graph.edges.filter(e => e.u === u.id && e.v === v.id);
      if (parallelEdges.length > 1) {
          const idx = parallelEdges.findIndex(e => e.id === edge.id);
          // Stagger: -20, 0, +20
          const offset = (idx - (parallelEdges.length-1)/2) * 25;
          labelX += perpX * offset;
          labelY += perpY * offset;
      }
  }

  // 5. Adaptive Label Sizing based on Density
  const nodeCount = state.graph.nodes.length;
  const edgeCount = state.graph.edges.length;
  const maxPossible = nodeCount * (nodeCount - 1);
  const density = maxPossible > 0 ? edgeCount / maxPossible : 0;
  
  // COMPACT SIZING for Grid Layout
  let rectW = 60, rectH = 22, fSize = '10';
  
  if (density > 0.35) { // Dense
      rectW = 45; rectH = 16; fSize = '9';
  } else if (density > 0.2) { // Medium
      rectW = 55; rectH = 20; fSize = '9';
  }

  const group = document.createElementNS(svgNS, "g");
  
  // Background
  const rect = document.createElementNS(svgNS, "rect");
  rect.setAttribute('x', labelX - rectW/2);
  rect.setAttribute('y', labelY - rectH/2);
  rect.setAttribute('width', rectW);
  rect.setAttribute('height', rectH);
  rect.setAttribute('rx', '4');
  rect.setAttribute('fill', 'rgba(255, 255, 255, 0.95)');
  rect.setAttribute('stroke', 'var(--border-medium)');
  rect.setAttribute('stroke-width', '1');
  group.appendChild(rect);
  
  // Text
  const text = document.createElementNS(svgNS, "text");
  text.setAttribute('x', labelX);
  text.setAttribute('y', labelY);
  text.setAttribute('text-anchor', 'middle');
  text.setAttribute('dominant-baseline', 'middle');
  text.setAttribute('font-family', 'JetBrains Mono, monospace');
  text.setAttribute('font-size', fSize);
  text.setAttribute('font-weight', '600');
  
  if (state.showFlow) {
    text.textContent = `${edge.flow}/${edge.capacity}`;
    text.setAttribute('fill', edge.flow > 0 ? '#059669' : '#64748b');
  } else {
    const residual = state.residualGraph.get(edge.u)?.get(edge.v) || 0;
    text.textContent = `res: ${residual}`;
    text.setAttribute('fill', '#3b82f6');
  }
  
  group.appendChild(text);
  return group;
}
// UI Update Functions
function updateMetrics() {
  const runtime = state.initialized ? Date.now() - state.startTime : 0;
  const n = state.graph.nodes.length;
  const e = state.graph.edges.length;
  const maxPossibleEdges = n * (n - 1);
  const density = maxPossibleEdges > 0 ? ((e / maxPossibleEdges) * 100).toFixed(1) : 0;
  
  // Update header
  document.getElementById('headerFlow').textContent = state.maxFlow;
  document.getElementById('headerPaths').textContent = state.pathCount;
  document.getElementById('headerTime').textContent = `${runtime}ms`;
  
  // Update metrics panel
  document.getElementById('maxFlowValue').textContent = state.maxFlow;
  document.getElementById('pathsValue').textContent = state.pathCount;
  document.getElementById('timeValue').textContent = `${runtime}ms`;
  document.getElementById('densityValue').textContent = `${density}%`;
}

function updateExplanationStep(step) {
  const explanationSteps = document.querySelectorAll('.explanation-step');
  explanationSteps.forEach(stepEl => stepEl.classList.remove('active'));
  
  const activeStep = document.querySelector(`.explanation-step[data-step="${step}"]`);
  if (activeStep) {
    activeStep.classList.add('active');
  }
}

function addPathToHistory(path, bottleneck) {
  const history = document.getElementById('pathHistory');
  
  // Remove placeholder if present
  const placeholder = history.querySelector('div[style*="text-align: center"]');
  if (placeholder) placeholder.remove();
  
  const pathItem = document.createElement('div');
  pathItem.className = 'path-item';
  pathItem.innerHTML = `
    <div class="path-nodes">${path.join(' → ')}</div>
    <div class="path-info">
      <span style="color: var(--accent-warning);">Bottleneck: ${bottleneck}</span>
      <span class="path-flow">+${bottleneck} flow</span>
    </div>
  `;
  
  history.insertBefore(pathItem, history.firstChild);
  
  // Limit history to 10 items
  const items = history.querySelectorAll('.path-item');
  if (items.length > 10) {
    items[items.length - 1].remove();
  }
}

function clearPathHistory() {
  const history = document.getElementById('pathHistory');
  history.innerHTML = `
    <div style="text-align: center; color: var(--text-muted); padding: 2rem;">
      <i class="fas fa-route" style="font-size: 1.5rem; margin-bottom: 0.5rem; opacity: 0.5;"></i>
      <div>No augmenting paths found yet</div>
    </div>
  `;
}

function addLog(message, type = "info") {
  const logPanel = document.getElementById('logPanel');
  const now = new Date();
  const timeString = `${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
  
  const logEntry = document.createElement('div');
  logEntry.className = `log-entry ${type}`;
  logEntry.innerHTML = `
    <span class="log-time">${timeString}</span>
    <span class="log-message">${message}</span>
  `;
  
  logPanel.appendChild(logEntry);
  logPanel.scrollTop = logPanel.scrollHeight;
  
  // Limit log to 20 entries
  const entries = logPanel.querySelectorAll('.log-entry');
  if (entries.length > 20) {
    entries[0].remove();
  }
}

function clearLog() {
  const logPanel = document.getElementById('logPanel');
  logPanel.innerHTML = `
    <div class="log-entry info">
      <span class="log-time">00:00</span>
      <span class="log-message">Log cleared</span>
    </div>
  `;
}

function updateStatus(message) {
  const statusText = document.getElementById('statusText');
  statusText.textContent = message;
}

function showToast(message, type = "info") {
  // Remove existing toasts
  document.querySelectorAll('.toast').forEach(toast => toast.remove());
  
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.innerHTML = `
    <i class="fas fa-${type === 'success' ? 'check-circle' : 
                      type === 'error' ? 'exclamation-circle' : 
                      type === 'warning' ? 'exclamation-triangle' : 'info-circle'}"></i>
    <span>${message}</span>
  `;
  
  document.body.appendChild(toast);
  
  // Auto-remove after 3 seconds
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateX(100%)';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// Initialize the application
window.addEventListener('DOMContentLoaded', init);
</script>

<script src="..\assets\js\iframeResize.js"></script></body>
</html>